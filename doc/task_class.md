# Task Class

Task is a class to support concurrent execution of mruby/c.
When executing multiple programs concurrently, one program can control the execution state of the other programs.
By using Task, the program can be executed by giving its bytecode.


## Task controlling

mruby/c has the feature of concurrently executing multiple programs.
Each concurrently running program is called a task.
The Task class provides a function to control the operation of another task from one task.

Each task is named by `name` member. Tasks can be distinguished by its name. 
Tasks can be controlled from one task to another by specifying task's name.

To name a task, assign a string value to `name` member as following.

```Ruby
Task.name = "Task1"

while true
  puts "task 1"
  sleep 1
end
```

When this program is executed, this `Task1` outputs `"task1"`.

`Task1` can be controlled from another task. When the method suspend is called, the output `"task 1"` will be stopped.
In the following program, the output of `"task1"` stops 10 seconds after the program starts. And more, five seconds later, the output of `"task 1"` resumes.



```Ruby
sleep 10

task1 = Task.get("Task1");

puts "Suspend Task1"
task1.suspend

sleep 5

puts "Resume Task1"
task1.resume
```


## Create new task

A new task can be created by `create` method, given the mruby bytecode.

```Ruby
byte_code = "RITE0300\x00\x00\x00xMATZ0000IREP\x00\x00\x00\\0300\x00\x00\x00P\x00\x02\x00\a\x00\x00\x00\x00\x00\x00\x00\"\x06\x01Q\x03\x00\x01\x04\x01=\x04\x01\x01\x01\x04R\x03-\x02\x00\x01\a\x03-\x02\x01\x01%\xFF\xE5\x11\x028\x02i\x00\x01\x00\x00\aTask1: \x00\x00\x02\x00\x04puts\x00\x00\x05sleep\x00END\x00\x00\x00\x00\b"

task1 = Task.create(byte_code)
task1.run
```

`byte_code` is the generated bytecode by compiling the following program.

```Ruby
i = 0
while true
  puts "Task1: #{i += 1}"
  sleep 1
end
```

The new generated task is initially in a stopped state (`TASKSTATE_DORMANT`).
Use `run` method to execute the task. 


## Sync tasks


```Ruby
Task.name = "Task1"

10.times do |i|
  puts "task 1 #{i}"
  sleep 1
end
```

```Ruby
task1 = Task.get("Task1");

3.times do |i|
    puts "task 2 #{i}"
    sleep 1.5
end

puts "Waiting for Task1"

task1.join

puts "Tasks completed"
```

<hr>


## Methods

**create( byte_code, regs_size = nil ) -> Task**

Create a new task from bytecode and return an object of the generated task.

The register size to be allocated by the VM is passed in the `size` parameter. If `size` is not given, the register size is the default value (MAX_REGS_SIZE).

The generated task is in the stopped state initially. To run a task in the stopped state, use `run` method.

**run**

Execute a task, which is created by `create` method and in the stopped state.

**rewind**

Initialize and execute a stopped task.

<hr/>

**name=**

Set task name.ã€€`name` methods names its own task.

**name**

Get task name.

**priority=**

Set task priority, which is 0 to 255. The highest priority is 0.

**priority**

Get task priority.

<hr/>

**current -> Task**<br>
**get -> Task**<br>
**get(task_name) -> Task**

Return task name, which is named by `name`.

If `task_name` is not given, `get` returns its own task(myself).

If `task_name` is not found, `get` returns nil.

**list() -> Array[Task]**

Return array of tasks, which are not only running tasks but also stopped tasks.

**name_list() -> Array[String]**

Return array of task names.

**status() -> String**

Return task status as string like `READY`, `WAITING`, `SUSPENDED` or `DORMANT`.
Especially in `WAITING` status, `stauts` returns its reason like `WAITING SLEEP`.


<hr/>

**suspend**

Suspend a task. To suspend other task, first get the task object by using `get`, and use `suspend` method. To suspend its own task, use `Task.suspend`.

**resume**

Resume(Continue) the suspended task.

**terminate**

Terminate a task.

**raise()**<br>
**raise(Exception)**

Throw an exeption into other task. If `Exception` is not given, `RuntimeError` is thrown.

<hr/>

**join() -> Task**

Wait for a task. `join` synchronizes between its own task and another task.

**pass()**

Pass the execution slot to another task. Release its own running status.

**value -> Object**

Return task termination value.
