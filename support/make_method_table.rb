#!/usr/bin/env ruby
# coding: utf-8
#
# create built-in method table include file.
#
#  Copyright (C) 2015-2020 Kyushu Institute of Technology.
#  Copyright (C) 2015-2020 Shimane IT Open-Innovation Center.
#
#  This file is distributed under BSD 3-Clause License.
#
# (usage)
# ruby make_method_table.rb TARGET_CLASS_FILE.c
#

require_relative "rename_for_symbol"

##
# strip double quot
#
def strip_double_quot( s )
  ret = s.dup
  ret.slice!(0)  if ret[0] == '"'
  ret.chop! if ret[-1] == '"'

  return ret
end


#
# find and get source code.
#
def get_method_table_source( file )
  ret = nil

  # find magic comment
  while txt = file.gets
    if /\/\*\s+MRBC_AUTOGEN_METHOD_TABLE/ =~ txt
      ret = ""
      break
    end
  end
  return nil  if !ret

  while txt = file.gets
    # skip comment and empty line.
    txt = txt.split("//", 2)[0].strip
    next if txt.empty?

    break  if txt.start_with?("*/")
    ret << txt << "\n"
  end

  return ret
end


##
# parser
#
# (note)
#  create hash, below.
# {
#   class: "Range",
#   file: "c_range_method_table.h",
#   func: "mrbc_init_class_range",
#   super: "mrbc_class_object",
#   methods: [
#     { name: "first", func: "c_range_first", if_exp: "" }
#       ...
#   ]
# }
#
def parse_source_string( src )
  flag_error = false
  ret = { methods:[] }
  if_exp = []
  src.each_line {|txt|
    # e.g. "#if ..."
    if /^#\s*if/ =~ txt
      if_exp << txt
      next
    end
    if /^#\s*endif/ =~ txt
      if_exp.pop
      next
    end

    # e.g. CLASS, METHOD and etc.
    if /^([A-Z]+)\s*\((.*)\)/ =~ txt
      key = $1
      args = $2.split(",").map {|s| s.strip }
      flag_arg_ok = true
      case key
      when "CLASS", "FILE", "FUNC", "SUPER"
        if args.size == 1
          ret[key.downcase.to_sym] = args[0]
        else
          flag_arg_ok = false
        end

      when "METHOD"
        if args.size == 2
          ret[:methods] << { name: strip_double_quot(args[0]), func: args[1] }
          ret[:methods].last[:if_exp] = if_exp.dup  if !if_exp.empty?
        else
          flag_arg_ok = false
        end

      else
        puts "Error: Invalid keyword. '#{key}'"
      end

      if !flag_arg_ok
        puts "Error: argument error. #{txt}"
      end
      next
    end

    puts "Error: #{txt}"
    flag_error = true
  }

  ret[:super] ||= "mrbc_class_object"

  return flag_error ? nil : ret
end


##
# error check
#
def check_error( param )
  flag_error = false

  if !param[:class]
    puts "Error: 'CLASS' parameter required"
    flag_error = true
  end
  if !param[:file]
    puts "Error: 'FILE' parameter required"
    flag_error = true
  end
  if !param[:func]
    puts "Error: 'FUNC' parameter required"
    flag_error = true
  end

  return !flag_error
end


##
# output header file
#
def output_header_file( param )
  flag_error = false
  param[:methods].sort_by! {|m| m[:name] }

  begin
    file = File.open( strip_double_quot(param[:file]), "w" )
  rescue Errno::ENOENT
    puts "File can't open. #{param[:file]}"
    return false
  end

  file.puts "/* Auto generated by make_method_table.rb */"
  file.puts "#include \"symbol_builtin.h\""
  file.puts "struct RClass *#{strip_double_quot(param[:func])}(struct VM *vm)"
  file.puts "{"
  file.puts "  static const mrbc_sym method_symbols[] = {"

  param[:methods].each {|m|
    file.puts m[:if_exp].join  if m[:if_exp]
    file.puts "    MRBC_SYMID_#{rename_for_symbol(m[:name])},"
    m[:if_exp].size.times { file.puts "#endif" }  if m[:if_exp]
  }
  file.puts "  };"

  file.puts "  static const mrbc_func_t method_functions[] = {"
  param[:methods].each {|m|
    file.puts m[:if_exp].join  if m[:if_exp]
    file.puts "    #{m[:func]},"
    m[:if_exp].size.times { file.puts "#endif" }  if m[:if_exp]
  }
  file.puts "  };"
  file.puts

  file.puts "  return mrbc_define_builtin_class(#{param[:class]}, #{param[:super]}, method_symbols, method_functions, sizeof(method_symbols)/sizeof(mrbc_sym) );"
  file.puts "}"

  file.close
end


##
# main
#
if !ARGV[0]
  puts <<EOL
(usage)
ruby make_method_table.rb TARGET_CLASS_FILE.c
EOL
  exit 1
end
filename = ARGV[0]

begin
  file = File.open( filename )
rescue Errno::ENOENT
  puts "File not found. '#{filename}'"
  exit 1
end

src = get_method_table_source( file )
if !src
  puts %!Magic comment "MRBC_AUTOGEN_METHOD_TABLE" is not found. '#{filename}'!
  exit 1
end

while src
  param = parse_source_string( src )
  exit 1 if !param
  exit 1 if !check_error( param )
  output_header_file( param )

  src = get_method_table_source( file )
end
